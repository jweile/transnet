/*
 *  Copyright (C) 2011 The Roth Lab
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package ca.on.mshri.transnet.algo;

import com.hp.hpl.jena.ontology.Individual;
import com.hp.hpl.jena.query.Query;
import com.hp.hpl.jena.query.QueryExecution;
import com.hp.hpl.jena.query.QueryExecutionFactory;
import com.hp.hpl.jena.query.QueryFactory;
import com.hp.hpl.jena.query.QueryParseException;
import com.hp.hpl.jena.query.QuerySolution;
import com.hp.hpl.jena.query.ResultSet;
import com.hp.hpl.jena.rdf.model.Model;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.net.URISyntaxException;
import java.net.URL;
import java.security.CodeSource;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

/**
 * This class indexes SPARQL queries from the resources folder.
 * 
 * @author Jochen Weile <jochenweile@gmail.com>
 */
public class Sparql {
    
    /**
     * map for indexing queries.
     */
    private Map<String,String> queries = new HashMap<String,String>();
    
    /**
     * singleton
     */
    private static Sparql instance;

    /**
     * singleton constructor.
     */
    private Sparql() {
        read();
    }

    /**
     * @return 
     * singleton
     */
    public static Sparql getInstance() {
        if (instance == null) {
            instance = new Sparql();
        }
        return instance;
    }

    /**
     * performs the indexing from the resources directory.
     */
    private void read() {
        
        CodeSource src = Sparql.class.getProtectionDomain().getCodeSource();
        
        if (src != null && src.getLocation().toString().endsWith(".jar")) {
            
            URL jarURL = src.getLocation();
            try {
                ZipFile jar = new ZipFile(new File(jarURL.toURI()));

                Enumeration<? extends ZipEntry> entries = jar.entries();
                while (entries.hasMoreElements()) {
                    
                    ZipEntry entry = entries.nextElement();
                    if (entry.getName().startsWith("sparql/") && 
                            entry.getName().endsWith(".sparql")) {
                        read(entry.getName(), jar.getInputStream(entry));
                    }
                    
                }

            } catch (IOException e) {
                throw new RuntimeException("Error reading from code source.", e);
            } catch (URISyntaxException e) {
                //shouldn't happen, as autogenerated
            }
            
        } else {
            
            File dir = new File("src/main/resources/sparql/");
            for (File file : dir.listFiles()) {
                try {
                    read(file.getAbsolutePath(), new FileInputStream(file));
                } catch (FileNotFoundException ex) {
                    //can't happen, unless it got deleted after the list() command.
                }
            }
        }
        
    }

    private void read(String path, InputStream inputStream) {
        
        String[] split = path.split("/");
        String filename = split[split.length-1];
        String name = filename.split("\\.")[0];
        
        try {
            
            String q = IO.getInstance().read(path, inputStream);
            queries.put(name, q);
            
        } catch (QueryParseException e) {
            throw new RuntimeException("Query "+path+" could not be parsed! ", e);
        } 
    }
    
    /**
     * Get the query for the given key
     * 
     * @param key 
     * the query key corresponds to the SPARQL file name
     * 
     * @return 
     * the query object
     */
    public Query get(String key) {
        
        String qString = queries.get(key);
        try {
            Query q = QueryFactory.create(qString);
            return q;
        } catch (QueryParseException e) {
            throw new RuntimeException("Query could not be parsed! ", e);
        }
    }
    
    /**
     * Get the query for the given key with the give parameters
     * 
     * @param key
     * the query key corresponds to the SPARQL file name
     * 
     * @param values 
     * Strings to replace %s tags in the query string before instantiating the query.
     * 
     * @return 
     * the query object.
     */
    public Query get(String key, String... values) {
        
        String qString = queries.get(key);
        try {
            Query q = QueryFactory.create(String.format(qString, (Object[])values));
            return q;
        } catch (QueryParseException e) {
            throw new RuntimeException("Query could not be parsed! ", e);
        }
    }
    
    /**
     * Performs a SPARQL query that returns a list of individuals.
     * 
     * @param query
     * The name of the query. Corresponds to the name of the SPARQL file.
     * 
     * @param key 
     * The name of the key in the query, that represents the individuals.
     * 
     * @param args
     * additional <code>String</code> arguments that substitute 
     * '<code>%s</code>' tags in the query.
     * 
     * @return The list of individuals.
     */
    public List<Individual> queryIndividuals(Model model, String query, String key, String... args) {
        List<Individual> list = new ArrayList<Individual>();
        
        QueryExecution qexec = QueryExecutionFactory
                .create(get(query, args), model);
        
        try {
            ResultSet r = qexec.execSelect();
            while (r.hasNext()) {
                QuerySolution sol = r.next();
                
                Individual i = sol.getResource(key)
                        .as(Individual.class);
                
                list.add(i);
            }
        } finally {
            qexec.close();
        }
        
        return list;
    }
    
    
    
    
}
